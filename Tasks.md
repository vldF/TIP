## Lec #2:

### Что будет, если в нашу систему ввести тип Bool

Нужно будет учитывать при анализе `true` и `false`. Также, необходимо изменить правила анализа:

```
I                             [[I]] = int
B                             [[B]] = bool
E_1 == E_2                    [[E_1]] = [[E_2]] /\ [[E_1 == E_2]] = bool
E_1 > E_2                     [[E_1]] = [[E_2]] /\ [[E_1 > E_2]] = bool
if (E) {S}                    [[E]] = bool
if (E) {S_1} else {S_2}       [[E]] = bool
while(E) {S}                  [[E]] = bool
```

(представлены только новые/изменённые правила, B это `true` или `false`)

Precision не изменится, так как он и так обладает свойством soundness, а его recall ухудшится, так как в рамках текущей 
семантики TIP вполне нормально использовать значение арифметического выражения внутри, например, `if`, а новая 
вариация анализа не будет пропускать такой код.

### Что будет, если в систему ввести тип Array

Новый синтаксис:

```
arr[idx] = value;
x = arr[idx];
```
`arr` имеет тип `T[]`, где `T=[[value]]`, `idx` имеет тип `int` 

Пример новых правил типизации:

```
E[E_idx]                         [[E]] = alpha[] /\ [[E_idx]] = int /\ [[E[E_idx]]] = alpha
E[E_idx] = E_val                 [[E]] = [[E_val]][] /\ [[E_idx]] = int /\ [[E[E_idx]]] = [[E_val]] 
```

Дополнительно (для следующего пункта) введем правила для типизации массивов-литералов:

```
{}                           [[{}]] = alpha[]
{E_1, E_2, .., E_n}          [[{E_1, E_2, .., E_n}]] = [[E_1]] = [[E_2]] = ... = [[E_n]] /\ [[{E_1, E_2, .., E_n}]] = [[E_1]][]  
```

### Попробуйте протипизировать программу со слайда

```tip
main() {
   var x,y,z,t;
   x = {2,4,8,16,32,64}; [[x]] = [[{2,4,8,16,32,64}]] /\ [[2]] = [[4]] = [[8]] = ... = [[64]]
   y = x[x[3]];          [[y]] = [[x[x[3]]]] = aplpa_x /\ [[x]] = alpha_x[] /\ [[x[3]]] = int /\ [[x]] = alpha_x'[] /\ [[3]] = int
   z = {{},x};           [[z]] = [[{{},x}]] /\ [[x]] = [[{}]]
   t = z[1];             [[t]] = [[z[1]]] = alpha_z /\ [[z]] = alpha_z[] /\ [[1]] = int
   t[2] = y;             [[t]] = alpha_t[] /\ [[2]] = int /\ [[y]] = alpha_t
}
```

```
[[x]] = int[]
[[y]] = int
[[z]] = int[][]
[[t]] = int[]

alpha_x = int
alpha_x' = int
alpha_z = int[]
alpha_t = int
```

### Подумайте, что происходит в получившейся реализации, если в программе есть рекурсивный тип?
   Если в программе есть рекурсивный тип, то анализатор все равно сможет типизировать программу, так как 
   рекурсивные типы разрешимы при помощи union-find

## Lec #3:

### Являются ли Top и Bottom точной верхней и нижней гранью какого-либо подмножества S?

Да, Top является точной верхней границей, а Bottom — нижней, например, у подмножества `{+0, -0, 0, -}` такой решётки:

![/images/img.png](/images/img.png)

### Уникальны ли они?

Не обязательно, например, если в решётке только один элемент, то он будет в ней и Top, и Bottom

### Как выглядит Top произведения решёток L_1, L_2, ..., L_n? А Bottom?

По определению произведения решёток, соответственно, (Top_L_1, Top_L_2, ..., Top_L_n) и 
(Bot_L_1, Bot_L_2, ..., Bot_L_n)

### Какая высота решётки произведений?

Высота решётки произведений равна сумме высот решёток-множителей

### Точные грани решётки отображений

По определению:

![img2.png](/images/img2.png)

Отсюда следует, что точная верхняя/нижняя граница это отображение, отображающее 
каждый элемент в Top или Bot (соответственно)

### Высота решётки отображений

По определению выше, высота решётки отображений равна произведению мощности
множества A на высоту решётки L: `|A| * h(L)`

### Можно ли выразить анализ типов с предыдущей лекции как анализ над решетками

Да, можно. Например, можно поместить все возможные типы в flat-решётку

### Можно ли выразить анализ над решётками как анализ типов

Да, можно, для этого надо ввести в систему типов Top и Bot. В некоторых языках
они уже введены, привет, kotlin. В нём при помощи наследования 
можно задать элементы решётки, неподвижной точкой в данном случае будет 
результат работы type checker'а. При этом, кажется, необходимо, чтобы решётка
была конечной, или чтобы у языка было какое-то средство для задания 
бесконечной решётки



## Lec #4:

### Сложность структурного алгоритма для liveness analysis?

Пусть n — количество узлов в CFG, c — количество переменных, 
h — высота решётки. Тогда искомую сложность можно записать как O(n*c) ~ O(n^2).
При этом, количество циклов никак не отражается на оценке

Сложность по памяти выражается в виде O(n*c) ~ O(n) так как мы храним только
информацию о жизни каждой переменной (а их значение заранее известно и константно) 
для каждого из узлов графа

### Расписать систему ограничений для примера выше и решить её

```tip
var x,a,b;           // {}
x = input;           // {}
a = x-1;             // {x-1}
b = x-2;             // {x-1, x-2}
while (x > 0) {      // {x-1, x>0}
  output a*b-x;      // {x-1, x>0, a*b, a*b-x}
  x = x-1;           // {a*b, x-1}
}
output a*b;          // {x-1, x>0}
```


## Lec #5:

### Предложите решетку для реализации анализа размера переменных

В качестве множества значений для widening возьмём множество 
`B = {-2^i, 2^i-1 | i in 0..31} U {-inf} U {+inf}`. Это позволит свести 
задачу к задаче анализа интервалов значений переменных. При необходимости можно
отобразить полученные интервалы значений на интервалы разрядностей в битах, а потом и на 
решётку из 6 типов из задания. Для каждого из них необходимо указать интервалы значений и в этом
случае при помощи widening можно будет свести решётку к тому, что требуется по заданию

## Lec #6

### Напишите вариант программы, для которой анализ открытости-закрытости файлов не показывает корректный результат

```tip
   var flag;
   flag = input();
   
   if (flag) {
      open();
   }
   // ...
   if (flag) {
      close();
   }
```

С точки зрения семантики TIP, `0 = false`, все другие значения — `true`. А с точки зрения наших
правил `flag` может быть только `0` или `1`. Тут же `flag` может быть произвольным числом. 
По этому, анализ из лекции не сработает в этом случае

### Предложите, каким образом можно решить описанные в лекции проблемы в этой ситуации

Можно расширить правила, чтобы учесть там два случая: `flag = 0` и `!(flag = 0)`.  В этом случае
всё должно заработать правильно


## Lec #7

### Напишите вариант программы, для которой контекстно-чувствительный анализ знаков требует коэффициент k>1

```tip
rec(arg) {
   if (arg > 0) { return rec(arg-1); }
   return arg
}

main() {
   output fact(10)
   output fact(-10)
}
```

### Приведите пример решётки, для которой контекстно-чувствительный анализ в функциональном стиле является более ресурсозатратным, чем контекстно-чувствительный анализ по месту вызова с глубиной 2

Решётка из всех булеана переменных (например, из анализа живости переменных). 
`States = Var -> 2^Var`. Оценим высоту решётки в обоих случаях:

1. По месту вызова с глубиной 2: `|Nodes| * 2 * |Var| * 2^(|Nodes|)`
2. В функциональном стиле: `|Nodes| * |Var| * 2^(|Nodes|) * |Var| * 2^(|Nodes|)`
