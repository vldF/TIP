## Lec #2:

### Что будет, если в нашу систему ввести тип Bool

Нужно будет учитывать при анализе `true` и `false`. Также, необходимо изменить правила анализа:

```
I                             [[I]] = int
B                             [[B]] = bool
E_1 == E_2                    [[E_1]] = [[E_2]] /\ [[E_1 == E_2]] = bool
E_1 > E_2                     [[E_1]] = [[E_2]] /\ [[E_1 > E_2]] = bool
if (E) {S}                    [[E]] = bool
if (E) {S_1} else {S_2}       [[E]] = bool
while(E) {S}                  [[E]] = bool
```

(представлены только новые/изменённые правила, B это `true` или `false`)

Precision не изменится, так как он и так обладает свойством soundness, а его recall ухудшится, так как в рамках текущей 
семантики TIP вполне нормально использовать значение арифметического выражения внутри, например, `if`, а новая 
вариация анализа не будет пропускать такой код.

### Что будет, если в систему ввести тип Array

Новый синтаксис:

```
arr[idx] = value;
x = arr[idx];
```
`arr` имеет тип `T[]`, где `T=[[value]]`, `idx` имеет тип `int` 

Пример новых правил типизации:

```
E[E_idx]                         [[E]] = alpha[] /\ [[E_idx]] = int /\ [[E[E_idx]]] = alpha
E[E_idx] = E_val                 [[E]] = [[E_val]][] /\ [[E_idx]] = int /\ [[E[E_idx]]] = [[E_val]] 
```

Дополнительно (для следующего пункта) введем правила для типизации массивов-литералов:

```
{}                           [[{}]] = alpha[]
{E_1, E_2, .., E_n}          [[{E_1, E_2, .., E_n}]] = [[E_1]] = [[E_2]] = ... = [[E_n]] /\ [[{E_1, E_2, .., E_n}]] = [[E_1]][]  
```

### Попробуйте протипизировать программу со слайда

```tip
main() {
   var x,y,z,t;
   x = {2,4,8,16,32,64}; [[x]] = [[{2,4,8,16,32,64}]] /\ [[2]] = [[4]] = [[8]] = ... = [[64]]
   y = x[x[3]];          [[y]] = [[x[x[3]]]] = aplpa_x /\ [[x]] = alpha_x[] /\ [[x[3]]] = int /\ [[x]] = alpha_x'[] /\ [[3]] = int
   z = {{},x};           [[z]] = [[{{},x}]] /\ [[x]] = [[{}]]
   t = z[1];             [[t]] = [[z[1]]] = alpha_z /\ [[z]] = alpha_z[] /\ [[1]] = int
   t[2] = y;             [[t]] = alpha_t[] /\ [[2]] = int /\ [[y]] = alpha_t
}
```

```
[[x]] = int[]
[[y]] = int
[[z]] = int[][]
[[t]] = int[]

alpha_x = int
alpha_x' = int
alpha_z = int[]
alpha_t = int
```

### Подумайте, что происходит в получившейся реализации, если в программе есть рекурсивный тип?
   Если в программе есть рекурсивный тип, то анализатор все равно сможет типизировать программу, так как 
   рекурсивные типы разрешимы при помощи union-find

## Lec #3:
1. Допишите метод transfer в трейте `IntraprocSignAnalysisFunctions` (по факту, в классе `SimpleSignAnalysis`)
2. Реализуйте класс `PowersetLattice` в классе `GenericLattices`

## Lec #4:
1. Допишите реализацию live variables analysis (`LiveVarsAnalysis.scala`)
2. Реализуйте reaching definitions analysis (`src/tip/analysis/ReachingDefinitionsAnalysis.scala`)

## Lec #5:
1. Допишите реализацию метода widen в `src/tip/analysis/IntervalAnalysis.scala`
2. Реализуйте придуманный вами анализ размера переменных в `src/tip/analysis/VariableSizeAnalysis.scala`
