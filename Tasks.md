## Lec #2:

### Что будет, если в нашу систему ввести тип Bool

Нужно будет учитывать при анализе `true` и `false`. Также, необходимо изменить правила анализа:

```
I                             [[I]] = int
B                             [[B]] = bool
E_1 == E_2                    [[E_1]] = [[E_2]] /\ [[E_1 == E_2]] = bool
E_1 > E_2                     [[E_1]] = [[E_2]] /\ [[E_1 > E_2]] = bool
if (E) {S}                    [[E]] = bool
if (E) {S_1} else {S_2}       [[E]] = bool
while(E) {S}                  [[E]] = bool
```

(представлены только новые/изменённые правила, B это `true` или `false`)

Precision не изменится, так как он и так обладает свойством soundness, а его recall ухудшится, так как в рамках текущей 
семантики TIP вполне нормально использовать значение арифметического выражения внутри, например, `if`, а новая 
вариация анализа не будет пропускать такой код.

### Что будет, если в систему ввести тип Array

Новый синтаксис:

```
arr[idx] = value;
x = arr[idx];
```
`arr` имеет тип `T[]`, где `T=[[value]]`, `idx` имеет тип `int` 

Пример новых правил типизации:

```
E[E_idx]                         [[E]] = alpha[] /\ [[E_idx]] = int /\ [[E[E_idx]]] = alpha
E[E_idx] = E_val                 [[E]] = [[E_val]][] /\ [[E_idx]] = int /\ [[E[E_idx]]] = [[E_val]] 
```

Дополнительно (для следующего пункта) введем правила для типизации массивов-литералов:

```
{}                           [[{}]] = alpha[]
{E_1, E_2, .., E_n}          [[{E_1, E_2, .., E_n}]] = [[E_1]] = [[E_2]] = ... = [[E_n]] /\ [[{E_1, E_2, .., E_n}]] = [[E_1]][]  
```

### Попробуйте протипизировать программу со слайда

```tip
main() {
   var x,y,z,t;
   x = {2,4,8,16,32,64}; [[x]] = [[{2,4,8,16,32,64}]] /\ [[2]] = [[4]] = [[8]] = ... = [[64]]
   y = x[x[3]];          [[y]] = [[x[x[3]]]] = aplpa_x /\ [[x]] = alpha_x[] /\ [[x[3]]] = int /\ [[x]] = alpha_x'[] /\ [[3]] = int
   z = {{},x};           [[z]] = [[{{},x}]] /\ [[x]] = [[{}]]
   t = z[1];             [[t]] = [[z[1]]] = alpha_z /\ [[z]] = alpha_z[] /\ [[1]] = int
   t[2] = y;             [[t]] = alpha_t[] /\ [[2]] = int /\ [[y]] = alpha_t
}
```

```
[[x]] = int[]
[[y]] = int
[[z]] = int[][]
[[t]] = int[]

alpha_x = int
alpha_x' = int
alpha_z = int[]
alpha_t = int
```

### Подумайте, что происходит в получившейся реализации, если в программе есть рекурсивный тип?
   Если в программе есть рекурсивный тип, то анализатор все равно сможет типизировать программу, так как 
   рекурсивные типы разрешимы при помощи union-find

## Lec #3:

### Являются ли Top и Bottom точной верхней и нижней гранью какого-либо подмножества S?

Да, Top является точной верхней границей, а Bottom — нижней, например, у подмножества `{+0, -0, 0, -}` такой решётки:

![/images/img.png](/images/img.png)

### Уникальны ли они?

Не обязательно, например, если в решётке только один элемент, то он будет в ней и Top, и Bottom

### Как выглядит Top произведения решёток L_1, L_2, ..., L_n? А Bottom?

По определению произведения решёток, соответственно, (Top_L_1, Top_L_2, ..., Top_L_n) и 
(Bot_L_1, Bot_L_2, ..., Bot_L_n)

### Какая высота решётки произведений?

Высота решётки произведений равна сумме высот решёток-множителей

### Точные грани решётки отображений

По определению:

![img2.png](/images/img2.png)

Отсюда следует, что точная верхняя/нижняя граница это отображение, отображающее 
каждый элемент в Top или Bot (соответственно)

### Высота решётки отображений

По определению выше, высота решётки отображений равна произведению мощности
множества A на высоту решётки L: `|A| * h(L)`

### Можно ли выразить анализ типов с предыдущей лекции как анализ над решетками

Да, можно. Например, можно поместить все возможные типы в flat-решётку

### Можно ли выразить анализ над решётками как анализ типов

Да, можно, для этого надо ввести в систему типов Top и Bot. В некоторых языках
они уже введены, привет, kotlin. В нём при помощи наследования 
можно задать элементы решётки, неподвижной точкой в данном случае будет 
результат работы type checker'а. При этом, кажется, необходимо, чтобы решётка
была конечной, или чтобы у языка было какое-то средство для задания 
бесконечной решётки



## Lec #4:

### Сложность структурного алгоритма для liveness analysis?

Пусть n — количество узлов в CFG, c — количество переменных, 
h — высота решётки. Тогда искомую сложность можно записать как O(n*c) ~ O(n^2).
При этом, количество циклов никак не отражается на оценке

Сложность по памяти выражается в виде O(n*c) ~ O(n) так как мы храним только
информацию о жизни каждой переменной (а их значение заранее известно и константно) 
для каждого из узлов графа

### Расписать систему ограничений для примера выше и решить её

```
var x,a,b;           // {}
x = input;           // {}
a = x-1;             // {x-1}
b = x-2;             // {x-1, x-2}
while (x > 0) {      // {x-1, x>0}
  output a*b-x;      // {x-1, x>0, a*b, a*b-x}
  x = x-1;           // {a*b, x-1}
}
output a*b;          // {x-1, x>0}
```


## Lec #5:
1. Допишите реализацию метода widen в `src/tip/analysis/IntervalAnalysis.scala`
2. Реализуйте придуманный вами анализ размера переменных в `src/tip/analysis/VariableSizeAnalysis.scala`
